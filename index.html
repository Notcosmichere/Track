<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Handheld Fluid Tank</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Consolas', monospace; }
        #ui-layer { position: absolute; top: 20px; left: 20px; color: #00ffcc; z-index: 100; pointer-events: none; }
        
        #debug-box { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 240px; height: 180px; 
            border: 2px solid #00ffcc; border-radius: 8px; 
            background: #000; z-index: 200;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.5;}
        #sketch_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); z-index: 201; }
        
        #btn-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 300; }
        button { padding: 15px 40px; font-size: 1.2rem; cursor: pointer; background: #00ffcc; border: none; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>KINETIC_TANK_V4.0</h1>
    <div id="status">STATUS: READY</div>
</div>

<div id="btn-container"><button id="startBtn">ACTIVATE TANK</button></div>

<div id="debug-box">
    <video id="input_video" playsinline></video>
    <canvas id="sketch_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const PARTICLE_COUNT = 8000;
    const BOX_SIZE = 12; // Much smaller cube
    const GRAVITY = -0.15;
    const BOUNCE = -0.4;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 30;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Group to hold the Box and Particles together
    const tankGroup = new THREE.Group();
    scene.add(tankGroup);

    // The Smaller Cube
    const boxMesh = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(BOX_SIZE, BOX_SIZE, BOX_SIZE)),
        new THREE.LineBasicMaterial({ color: 0x00ffcc })
    );
    tankGroup.add(boxMesh);

    // Particles
    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const vel = new Float32Array(PARTICLE_COUNT * 3);
    const col = new Float32Array(PARTICLE_COUNT * 3);

    for(let i=0; i<PARTICLE_COUNT; i++) {
        pos[i*3] = (Math.random()-0.5) * BOX_SIZE;
        pos[i*3+1] = (Math.random()-0.5) * BOX_SIZE;
        pos[i*3+2] = (Math.random()-0.5) * BOX_SIZE;
        col[i*3]=0; col[i*3+1]=0.8; col[i*3+2]=1.0; 
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const points = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.2, vertexColors: true }));
    tankGroup.add(points);

    // Tracking variables
    const video = document.getElementById('input_video');
    const canvas = document.getElementById('sketch_canvas');
    const ctx = canvas.getContext('2d');
    let targetPos = new THREE.Vector3(0, 0, 0);
    let lastTankPos = new THREE.Vector3(0, 0, 0);

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

    hands.onResults((res) => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const lm = res.multiHandLandmarks[0];
            drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00FFCC', lineWidth: 3});
            
            // Center of the palm (landmark 9 - Middle finger MCP)
            const palm = lm[9];
            targetPos.set((palm.x - 0.5) * -40, (palm.y - 0.5) * -30, (palm.z * -50));
            document.getElementById('status').innerText = "STATUS: CUBE CAPTURED";
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        
        // Move the Tank towards the hand
        tankGroup.position.lerp(targetPos, 0.15);
        
        // Calculate the "Inertia" (force caused by moving the tank)
        const inertia = new THREE.Vector3().subVectors(tankGroup.position, lastTankPos);
        lastTankPos.copy(tankGroup.position);

        const pArr = geometry.attributes.position.array;
        const h = BOX_SIZE / 2;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3, iy = i*3+1, iz = i*3+2;

            // Gravity
            vel[iy] += GRAVITY;

            // Apply Inertia (Particles feel the movement of the box)
            vel[ix] -= inertia.x * 0.5;
            vel[iy] -= inertia.y * 0.5;
            vel[iz] -= inertia.z * 0.5;

            // Particle Movement
            pArr[ix] += vel[ix]; pArr[iy] += vel[iy]; pArr[iz] += vel[iz];

            // Boundaries (Stay inside the cube)
            if (Math.abs(pArr[ix]) > h) { pArr[ix] = Math.sign(pArr[ix])*h; vel[ix] *= BOUNCE; }
            if (Math.abs(pArr[iy]) > h) { pArr[iy] = Math.sign(pArr[iy])*h; vel[iy] *= BOUNCE; vel[ix] *= 0.9; }
            if (Math.abs(pArr[iz]) > h) { pArr[iz] = Math.sign(pArr[iz])*h; vel[iz] *= BOUNCE; }
        }

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    document.getElementById('startBtn').onclick = () => {
        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });
        cam.start().then(() => {
            document.getElementById('btn-container').style.display='none';
            animate();
        });
    };
</script>
</body>
</html>
