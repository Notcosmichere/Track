<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fluid Sim - Compact Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Consolas', monospace; }
        
        #ui-layer { 
            position: absolute; top: 20px; left: 20px; color: #ff3300; 
            z-index: 100; pointer-events: none;
        }

        /* Small Debug Box */
        #debug-box { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 240px; height: 180px; 
            border: 2px solid #ff3300; border-radius: 8px; 
            overflow: hidden; z-index: 200; background: #000;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #sketch_canvas { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            transform: scaleX(-1); z-index: 201; /* Layered on top */
        }
        
        #btn-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 300; }
        button { 
            padding: 15px 40px; font-size: 1.2rem; cursor: pointer; 
            background: #111; color: #ff3300; border: 1px solid #ff3300; 
            font-family: 'Consolas', monospace; text-transform: uppercase;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>FLUID_SIM_V2.0</h1>
    <div id="status">STATUS: STANDBY</div>
</div>

<div id="btn-container"><button id="startBtn">INITIALIZE</button></div>

<div id="debug-box">
    <video id="input_video" playsinline></video>
    <canvas id="sketch_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const PARTICLE_COUNT = 5000;
    const BOX_SIZE = 25; // Smaller, more compact cube
    const GRAVITY = -0.12;
    const BOUNCE = -0.5;

    // --- THREE.JS ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 45; // Adjusted zoom for smaller cube
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const boxGeo = new THREE.BoxGeometry(BOX_SIZE, BOX_SIZE, BOX_SIZE);
    const boxEdges = new THREE.EdgesGeometry(boxGeo);
    const boxMesh = new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({ color: 0xff3300 }));
    scene.add(boxMesh);

    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const vel = new Float32Array(PARTICLE_COUNT * 3);
    const col = new Float32Array(PARTICLE_COUNT * 3);

    for(let i=0; i<PARTICLE_COUNT; i++) {
        pos[i*3] = (Math.random()-0.5) * BOX_SIZE;
        pos[i*3+1] = (Math.random()-0.5) * BOX_SIZE;
        pos[i*3+2] = (Math.random()-0.5) * BOX_SIZE;
        col[i*3]=1; col[i*3+1]=0.1; col[i*3+2]=0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const points = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.4, vertexColors: true }));
    scene.add(points);

    // --- HANDS & SKELETON ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('sketch_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    let handTarget = new THREE.Vector3(1000, 1000, 1000);

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

    hands.onResults((res) => {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const lm = res.multiHandLandmarks[0];
            
            // Draw Skeleton
            window.drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {color: '#00FFCC', lineWidth: 4});
            window.drawLandmarks(canvasCtx, lm, {color: '#FF3300', radius: 3});

            // Map Index Finger to 3D Space
            const tip = lm[8];
            handTarget.set((tip.x - 0.5) * -BOX_SIZE * 2, (tip.y - 0.5) * -BOX_SIZE * 2, 0);
            document.getElementById('status').innerText = "STATUS: TRACKING";
        } else {
            handTarget.set(1000, 1000, 1000);
            document.getElementById('status').innerText = "STATUS: SEARCHING";
        }
    });

    // --- PHYSICS & ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        const pArr = geometry.attributes.position.array;
        const half = BOX_SIZE / 2;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3, iy = i*3+1, iz = i*3+2;

            vel[iy] += GRAVITY;

            // Simple hand repulsion
            const dx = pArr[ix] - handTarget.x;
            const dy = pArr[iy] - handTarget.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 5) {
                vel[ix] += (dx/dist) * 0.5;
                vel[iy] += (dy/dist) * 0.5;
            }

            pArr[ix] += vel[ix]; pArr[iy] += vel[iy]; pArr[iz] += vel[iz];

            // Boundaries
            if (Math.abs(pArr[ix]) > half) { pArr[ix] = Math.sign(pArr[ix]) * half; vel[ix] *= BOUNCE; }
            if (pArr[iy] < -half) { pArr[iy] = -half; vel[iy] *= BOUNCE; vel[ix] *= 0.9; }
            if (pArr[iy] > half) { pArr[iy] = half; vel[iy] *= BOUNCE; }
            if (Math.abs(pArr[iz]) > half) { pArr[iz] = Math.sign(pArr[iz]) * half; vel[iz] *= BOUNCE; }
        }

        geometry.attributes.position.needsUpdate = true;
        scene.rotation.y += 0.005;
        renderer.render(scene, camera);
    }

    document.getElementById('startBtn').onclick = () => {
        new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        }).start().then(() => {
            document.getElementById('btn-container').style.display='none';
            animate();
        });
    };
</script>
</body>
</html>
