<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fluid Surface Simulation</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        #input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); z-index: 1; }
        #sketch_canvas { position: absolute; width: 100%; height: 100%; top: 0; left: 0; transform: scaleX(-1); z-index: 2; }
        #three_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none; }
        #ui-layer { position: absolute; top: 20px; left: 20px; color: #00ffcc; z-index: 100; font-family: 'Courier New', monospace; }
        #btn-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 300; }
        button { padding: 20px 50px; font-size: 1.2rem; cursor: pointer; background: #00ffcc; border: none; font-weight: bold; border-radius: 5px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>FLUID_LINK_V6</h1>
    <div id="status">STATUS: CALIBRATING...</div>
</div>

<div id="btn-container"><button id="startBtn">START FLUID LINK</button></div>
<video id="input_video" playsinline></video>
<canvas id="sketch_canvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const PARTICLE_COUNT = 4500; // Lower count with higher cohesion looks more like liquid
    const BOX_SIZE = 6; // Very small cube
    const GRAVITY = -0.08;
    const COHESION = 0.02; // This makes them act like water
    const FRICTION = 0.96;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 20;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.id = "three_canvas";
    document.body.appendChild(renderer.domElement);

    const tankGroup = new THREE.Group();
    scene.add(tankGroup);

    // Box Visual
    const boxMesh = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(BOX_SIZE, BOX_SIZE, BOX_SIZE)),
        new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.5 })
    );
    tankGroup.add(boxMesh);

    // Liquid Visual
    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const vel = new Float32Array(PARTICLE_COUNT * 3);

    for(let i=0; i<PARTICLE_COUNT; i++) {
        pos[i*3] = (Math.random()-0.5) * BOX_SIZE;
        pos[i*3+1] = (Math.random()-0.5) * BOX_SIZE;
        pos[i*3+2] = (Math.random()-0.5) * BOX_SIZE;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    
    // Texture for "Blurry/Fluid" particles
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
    const material = new THREE.PointsMaterial({ 
        size: 0.5, 
        color: 0x00d4ff, 
        map: sprite, 
        transparent: true, 
        alphaTest: 0.01, 
        blending: THREE.AdditiveBlending 
    });
    
    const liquid = new THREE.Points(geometry, material);
    tankGroup.add(liquid);

    // Tracking
    const video = document.getElementById('input_video');
    const canvas = document.getElementById('sketch_canvas');
    const ctx = canvas.getContext('2d');
    let targetPos = new THREE.Vector3(0, 0, 0);
    let lastTankPos = new THREE.Vector3(0, 0, 0);

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });

    hands.onResults((res) => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const lm = res.multiHandLandmarks[0];
            drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00FFCC', lineWidth: 4});
            
            const palm = lm[9]; // Hand center
            targetPos.set((palm.x - 0.5) * -30, (palm.y - 0.5) * -20, (palm.z * -30));
            document.getElementById('status').innerText = "STATUS: HAND LOCKED";
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        
        tankGroup.position.lerp(targetPos, 0.2);
        const deltaMove = new THREE.Vector3().subVectors(tankGroup.position, lastTankPos);
        lastTankPos.copy(tankGroup.position);

        const pArr = geometry.attributes.position.array;
        const h = BOX_SIZE / 2;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3, iy = i*3+1, iz = i*3+2;

            // Gravity
            vel[iy] += GRAVITY;

            // Slosh Force (Inertia)
            vel[ix] -= deltaMove.x * 0.5;
            vel[iy] -= deltaMove.y * 0.5;
            vel[iz] -= deltaMove.z * 0.5;

            // Simple Cohesion (Pull toward center of mass slightly)
            vel[ix] -= pArr[ix] * COHESION;
            vel[iy] -= pArr[iy] * COHESION;
            vel[iz] -= pArr[iz] * COHESION;

            // Apply Velocity
            pArr[ix] += vel[ix]; pArr[iy] += vel[iy]; pArr[iz] += vel[iz];
            vel[ix] *= FRICTION; vel[iy] *= FRICTION; vel[iz] *= FRICTION;

            // Box Collisions
            if (Math.abs(pArr[ix]) > h) { pArr[ix] = Math.sign(pArr[ix])*h; vel[ix] *= -0.3; }
            if (Math.abs(pArr[iy]) > h) { pArr[iy] = Math.sign(pArr[iy])*h; vel[iy] *= -0.3; }
            if (Math.abs(pArr[iz]) > h) { pArr[iz] = Math.sign(pArr[iz])*h; vel[iz] *= -0.3; }
        }

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    document.getElementById('startBtn').onclick = () => {
        new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 1280, height: 720
        }).start().then(() => {
            document.getElementById('btn-container').style.display='none';
            animate();
        });
    };
</script>
</body>
</html>
