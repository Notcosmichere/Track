<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TVA: Temporal Loom & Yggdrasil</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        /* TVA RETRO UI */
        #ui-layer { 
            position: absolute; top: 20px; left: 20px; color: #ff9900; 
            z-index: 100; pointer-events: none; 
            text-shadow: 0 0 5px #ff9900;
        }
        h1 { font-size: 2rem; margin: 0; text-transform: uppercase; border-bottom: 2px solid #ff9900; display: inline-block;}
        .stat { font-size: 1rem; margin-top: 5px; opacity: 0.8; }
        
        #debug-box { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 260px; height: 195px; 
            border: 2px solid #ff9900; border-radius: 4px; 
            overflow: hidden; z-index: 200; background: #111;
            box-shadow: 0 0 15px rgba(255, 153, 0, 0.3);
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.5; }
        #sketch_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        
        #btn-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 300; }
        button { 
            padding: 20px 50px; font-size: 1.2rem; cursor: pointer; 
            background: #222; color: #ff9900; border: 2px solid #ff9900; 
            font-family: 'Courier New', monospace; text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 153, 0, 0.5);
        }
        button:hover { background: #ff9900; color: #000; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>TVA TERMINAL</h1>
    <div class="stat" id="status-text">STATUS: TIMELINE STABLE</div>
    <div class="stat">2: GOD OF STORIES (TREE)</div>
    <div class="stat">4: TEMPORAL LOOM (MACHINE)</div>
    <div class="stat">FIST: PRUNE TIMELINE</div>
</div>

<div id="btn-container"><button id="startBtn">ACCESS TIMELINE</button></div>

<div id="debug-box">
    <video id="input_video" playsinline></video>
    <canvas id="sketch_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const statusText = document.getElementById('status-text');
    const PARTICLE_COUNT = 25000; 
    let mode = 'loom';
    let time = 0;

    // --- THREE.JS SCENE ---
    const scene = new THREE.Scene();
    // Dark fog for the "End of Time" look
    scene.fog = new THREE.FogExp2(0x050505, 0.015);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 60;
    camera.position.y = 10;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const tar = new Float32Array(PARTICLE_COUNT * 3); // Target position
    const col = new Float32Array(PARTICLE_COUNT * 3);
    const extra = new Float32Array(PARTICLE_COUNT); // Store random offsets

    for(let i=0; i<PARTICLE_COUNT; i++) {
        pos[i*3] = (Math.random()-0.5)*100;
        pos[i*3+1] = (Math.random()-0.5)*100;
        pos[i*3+2] = (Math.random()-0.5)*100;
        extra[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
    
    const material = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // --- SHAPES ---

    // 1. GOD OF STORIES (Loki's Tree) - 2 Fingers
    // A spiraling trunk that blooms into infinite timelines
    function setYggdrasil() {
        statusText.innerText = "STATUS: WEAVING TIMELINES";
        statusText.style.color = "#00ff00";
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const t = i / PARTICLE_COUNT;
            const angle = t * Math.PI * 40; // High spiral count
            
            // Trunk (bottom) -> Bloom (top)
            const h = -40 + (t * 100); 
            
            // Radius expands as it goes up
            let r;
            if (h < -10) r = 2 + Math.random()*3; // Tight trunk
            else r = (h + 10) * 1.5 * Math.random(); // Exploding branches

            tar[i*3] = Math.cos(angle) * r;
            tar[i*3+1] = h;
            tar[i*3+2] = Math.sin(angle) * r;
            
            // COLOR: Loki Green at bottom -> Time Gold at top
            if (h < 0) {
                col[i*3]=0; col[i*3+1]=1; col[i*3+2]=0.2; // Green
            } else {
                col[i*3]=1; col[i*3+1]=0.8; col[i*3+2]=0.2; // Gold
            }
        }
    }

    // 2. TEMPORAL LOOM (The Machine) - 4 Fingers
    // A rigid ring + A chaotic horizontal beam
    function setLoom() {
        statusText.innerText = "STATUS: LOOM STABILIZED";
        statusText.style.color = "#00ffff";
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const seed = extra[i];
            
            if (seed < 0.3) { 
                // THE RING (Containment)
                const angle = Math.random() * Math.PI * 2;
                const r = 25;
                tar[i*3] = r * Math.cos(angle);
                tar[i*3+1] = r * Math.sin(angle);
                tar[i*3+2] = (Math.random()-0.5) * 5; // Thin ring width
                
                col[i*3]=0.8; col[i*3+1]=0.4; col[i*3+2]=0.0; // Bronze/Metal
            } else {
                // THE RAW TIME BEAM (Through the ring)
                // Chaos beam along Z-axis
                tar[i*3] = (Math.random()-0.5) * 10; // Narrow width
                tar[i*3+1] = (Math.random()-0.5) * 10; // Narrow height
                tar[i*3+2] = (Math.random()-0.5) * 200; // Long beam
                
                col[i*3]=0.6; col[i*3+1]=0.9; col[i*3+2]=1; // Cyan/White energy
            }
        }
    }

    // 3. PRUNE (The Void) - Fist
    // Particles float randomly like dust/smoke
    function setPrune() {
        statusText.innerText = "STATUS: TIMELINE PRUNED";
        statusText.style.color = "#aa00ff";
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 20 + Math.random() * 80;
            
            tar[i*3] = Math.cos(angle) * r;
            tar[i*3+1] = (Math.random()-0.5)*50;
            tar[i*3+2] = Math.sin(angle) * r;
            
            col[i*3]=0.4; col[i*3+1]=0; col[i*3+2]=0.8; // Purple Smoke
        }
    }

    setLoom(); // Default state

    // --- HAND TRACKING ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('sketch_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.6 });

    hands.onResults((res) => {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const lm = res.multiHandLandmarks[0];
            drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {color: '#ff9900', lineWidth: 2});
            
            const up = [8, 12, 16, 20].filter(id => lm[id].y < lm[id-2].y).length;
            const fist = lm[8].y > lm[5].y && lm[12].y > lm[9].y;

            if (fist) { if(mode!='prune'){ mode='prune'; setPrune(); } }
            else if (up === 4) { if(mode!='loom'){ mode='loom'; setLoom(); } }
            else if (up === 2) { if(mode!='tree'){ mode='tree'; setYggdrasil(); } }
        }
    });

    document.getElementById('startBtn').onclick = () => {
        new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        }).start().then(() => document.getElementById('btn-container').style.display='none');
    };

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        time += 0.02;
        const pArr = geometry.attributes.position.array;
        const cArr = geometry.attributes.color.array;

        // Rotation logic
        if (mode === 'tree') points.rotation.y += 0.005; // Slow majesty
        else if (mode === 'loom') points.rotation.z += 0.01; // Machine spinning
        else points.rotation.y += 0.002;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            
            // PHYSICS: Move towards target shape
            pArr[i3] += (tar[i3] - pArr[i3]) * 0.08;
            pArr[i3+1] += (tar[i3+1] - pArr[i3+1]) * 0.08;
            pArr[i3+2] += (tar[i3+2] - pArr[i3+2]) * 0.08;

            // SPECIAL EFFECTS (The "Loom" flow)
            if (mode === 'tree') {
                // Shimmering upward flow
                pArr[i3+1] += Math.sin(time + pArr[i3]*0.1) * 0.1;
            }
            if (mode === 'loom' && extra[i] >= 0.3) {
                // Beam particles rush fast along Z
                pArr[i3+2] += 2; 
                if (pArr[i3+2] > 100) pArr[i3+2] = -100; // Reset loop
            }

            // Color easing
            cArr[i3] += (col[i3] - cArr[i3]) * 0.05;
            cArr[i3+1] += (col[i3+1] - cArr[i3+1]) * 0.05;
            cArr[i3+2] += (col[i3+2] - cArr[i3+2]) * 0.05;
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
