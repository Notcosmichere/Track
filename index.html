<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Domain Expansion: Dual Hand Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        /* ANIME UI OVERLAY */
        #ui-layer { 
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%); 
            text-align: center; pointer-events: none; z-index: 10;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        h1 { 
            font-size: 3.5rem; margin: 0; color: white; letter-spacing: 5px; 
            text-transform: uppercase; animation: glitch 0.2s infinite; display: none;
        }
        h2 { font-size: 1.2rem; color: #00ffcc; margin-top: 5px; letter-spacing: 2px; }

        @keyframes glitch {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }

        #debug-box { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 240px; height: 180px; 
            border: 1px solid #555; border-radius: 8px; 
            overflow: hidden; z-index: 20; background: #000;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.6; }
        #sketch_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        
        #btn-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 30; }
        button { padding: 15px 40px; font-size: 1.2rem; cursor: pointer; background: white; color: black; border: none; font-weight: bold; letter-spacing: 2px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1 id="move-title">DOMAIN EXPANSION</h1>
    <h2 id="move-sub">SYSTEM READY</h2>
</div>

<div id="btn-container"><button id="startBtn">INITIALIZE TECHNIQUE</button></div>

<div id="debug-box">
    <video id="input_video" playsinline></video>
    <canvas id="sketch_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const titleEl = document.getElementById('move-title');
    const subEl = document.getElementById('move-sub');
    const PARTICLE_COUNT = 25000; // Dense particles for better domain effects
    let mode = 'neutral';
    let time = 0;

    // --- THREE.JS SCENE ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 50;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const tar = new Float32Array(PARTICLE_COUNT * 3);
    const col = new Float32Array(PARTICLE_COUNT * 3);

    // Initial random positions
    for(let i=0; i<PARTICLE_COUNT; i++) {
        pos[i*3] = (Math.random()-0.5)*100;
        pos[i*3+1] = (Math.random()-0.5)*100;
        pos[i*3+2] = (Math.random()-0.5)*100;
        col[i*3]=1; col[i*3+1]=1; col[i*3+2]=1;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));

    const material = new THREE.PointsMaterial({
        size: 0.35,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // --- DOMAIN FUNCTIONS ---

    function updateText(title, sub, color) {
        if(titleEl.innerText !== title) {
            titleEl.style.display = 'block';
            titleEl.innerText = title;
            titleEl.style.color = color;
            titleEl.style.textShadow = `0 0 20px ${color}`;
            subEl.innerText = sub;
            subEl.style.color = color;
        }
    }

    // 1. NEUTRAL (Idle)
    function setNeutral() {
        updateText("", "DETECTING CURSED ENERGY...", "#ffffff");
        scene.fog.color.setHex(0x000000);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            tar[i*3] = (Math.random()-0.5)*150;
            tar[i*3+1] = (Math.random()-0.5)*100;
            tar[i*3+2] = (Math.random()-0.5)*50;
            col[i*3]=0.5; col[i*3+1]=0.5; col[i*3+2]=0.5;
        }
    }

    // 2. INFINITE VOID (2 Fingers)
    function setInfiniteVoid() {
        updateText("INFINITE VOID", "DOMAIN EXPANSION", "#FFFFFF");
        scene.fog.color.setHex(0x000000);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const seed = Math.random();
            if (seed < 0.15) { // Vertical White Beam
                tar[i*3] = (Math.random()-0.5) * 5; 
                tar[i*3+1] = (Math.random()-0.5) * 120; 
                tar[i*3+2] = (Math.random()-0.5) * 5;
                col[i*3]=1; col[i*3+1]=1; col[i*3+2]=1;
            } else { // Starfield
                const r = 40 + Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                tar[i*3] = r * Math.sin(phi) * Math.cos(theta);
                tar[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                tar[i*3+2] = r * Math.cos(phi);
                col[i*3]=0; col[i*3+1]=0.8; col[i*3+2]=1; // Cyan
            }
        }
    }

    // 3. MALEVOLENT SHRINE (2 Hands Together)
    function setShrine() {
        updateText("MALEVOLENT SHRINE", "DOMAIN EXPANSION", "#FF0000");
        scene.fog.color.setHex(0x330000); // Deep Red Fog
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const seed = Math.random();
            if (seed < 0.5) { // The Blood Floor
                tar[i*3] = (Math.random()-0.5) * 200;
                tar[i*3+1] = -25 + (Math.random()*2); 
                tar[i*3+2] = (Math.random()-0.5) * 150;
                col[i*3]=0.8; col[i*3+1]=0; col[i*3+2]=0; 
            } else { // The Shrine Structure (Torii Gate Arch)
                const angle = Math.random() * Math.PI; // Semicircle arch
                const r = 30 + Math.random() * 5;
                tar[i*3] = r * Math.cos(angle);
                tar[i*3+1] = r * Math.sin(angle) - 10;
                tar[i*3+2] = -40 + (Math.random()*10);
                col[i*3]=0.6; col[i*3+1]=0; col[i*3+2]=0; 
            }
        }
    }

    // 4. HOLLOW PURPLE (3 Fingers)
    function setPurple() {
        updateText("HOLLOW PURPLE", "SECRET TECHNIQUE", "#D000FF");
        scene.fog.color.setHex(0x110022);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const r = Math.random() * 18;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            tar[i*3] = r * Math.sin(phi) * Math.cos(theta);
            tar[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            tar[i*3+2] = r * Math.cos(phi);
            col[i*3]=0.7; col[i*3+1]=0; col[i*3+2]=1; 
        }
    }

    // 5. RED (1 Finger)
    function setRed() {
        updateText("REVERSAL: RED", "CURSED TECHNIQUE", "#FF3333");
        scene.fog.color.setHex(0x220000);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const r = Math.random() * 6;
            const theta = Math.random() * Math.PI * 2;
            tar[i*3] = r * Math.cos(theta);
            tar[i*3+1] = r * Math.sin(theta);
            tar[i*3+2] = (Math.random()-0.5)*5;
            col[i*3]=1; col[i*3+1]=0; col[i*3+2]=0;
        }
    }

    setNeutral();

    // --- HAND TRACKING SETUP ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('sketch_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    
    // CRITICAL: ALLOW 2 HANDS FOR SHRINE SIGN
    hands.setOptions({ 
        maxNumHands: 2, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.6, 
        minTrackingConfidence: 0.6 
    });

    hands.onResults((res) => {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        let activeGesture = 'neutral';

        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            // Draw all hands
            for (const landmarks of res.multiHandLandmarks) {
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#ffffff', lineWidth: 2});
            }

            // CHECK FOR SHRINE (2 HANDS TOGETHER)
            if (res.multiHandLandmarks.length === 2) {
                const hand1 = res.multiHandLandmarks[0][0]; // Wrist of hand 1
                const hand2 = res.multiHandLandmarks[1][0]; // Wrist of hand 2
                
                // Calculate distance between wrists
                const dist = Math.sqrt(Math.pow(hand1.x - hand2.x, 2) + Math.pow(hand1.y - hand2.y, 2));
                
                // If wrists are close (adjust 0.2 if needed), trigger Shrine
                if (dist < 0.25) {
                    activeGesture = 'shrine';
                }
            }
            
            // If Shrine wasn't detected, check single hand gestures
            if (activeGesture === 'neutral') {
                const lm = res.multiHandLandmarks[0]; // Check primary hand
                const up = [8, 12, 16, 20].filter(id => lm[id].y < lm[id-2].y).length;
                
                if (up === 1) activeGesture = 'red';
                else if (up === 2) activeGesture = 'void';
                else if (up === 3) activeGesture = 'purple';
            }
        } 

        // Apply Gesture to Mode
        if (activeGesture !== mode) {
            mode = activeGesture;
            if (mode === 'shrine') setShrine();
            else if (mode === 'void') setInfiniteVoid();
            else if (mode === 'purple') setPurple();
            else if (mode === 'red') setRed();
            else setNeutral();
        }
    });

    document.getElementById('startBtn').onclick = () => {
        new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        }).start().then(() => document.getElementById('btn-container').style.display='none');
    };

    function animate() {
        requestAnimationFrame(animate);
        time += 0.05;
        const pArr = geometry.attributes.position.array;
        const cArr = geometry.attributes.color.array;

        if (mode === 'purple') points.rotation.z += 0.05;
        else if (mode === 'void') points.rotation.y += 0.002;
        else points.rotation.set(0,0,0);

        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            // Standard Ease-to-Target
            pArr[i] += (tar[i] - pArr[i]) * 0.1;
            cArr[i] += (col[i] - cArr[i]) * 0.1;
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
