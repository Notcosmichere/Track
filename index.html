<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kurupey Final Fix - Skeleton & Cosmic</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui-layer { position: absolute; top: 20px; left: 20px; color: white; z-index: 100; pointer-events: none; }
        #status-bar { color: #00ffcc; font-family: monospace; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 4px; }
        
        /* Debug Box with Skeleton */
        #debug-box { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 300px; height: 225px; 
            border: 2px solid #00ffcc; border-radius: 12px; 
            overflow: hidden; z-index: 200; background: #111;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #sketch_canvas { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            transform: scaleX(-1); 
            z-index: 201; /* Ensure skeleton is on top */
        }
        
        #btn-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 300; }
        button { padding: 20px 50px; font-size: 1.5rem; cursor: pointer; background: #00ffcc; border: none; border-radius: 50px; font-weight: bold; box-shadow: 0 0 25px #00ffcc; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>Cosmic Garden & Time</h1>
    <div id="status-bar">SYSTEM STATUS: READY</div>
    <p>2: Yggdrasil | 3: Rose Bloom | 4: Mobius | Fist: Sphere</p>
</div>

<div id="btn-container"><button id="startBtn">START ENGINE</button></div>

<div id="debug-box">
    <video id="input_video" playsinline></video>
    <canvas id="sketch_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const status = document.getElementById('status-bar');
    const PARTICLE_COUNT = 15000; 
    let mode = 'scatter';
    let roseGrowth = 0;
    let globalTime = 0;

    // --- 1. Three.js Setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    camera.position.z = 70;

    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const tar = new Float32Array(PARTICLE_COUNT * 3);
    const col = new Float32Array(PARTICLE_COUNT * 3);

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const points = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.2, vertexColors: true, blending: THREE.AdditiveBlending }));
    scene.add(points);

    // --- 2. Shape Functions ---
    function setMobius() {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const t = (i / PARTICLE_COUNT) * Math.PI * 2;
            const x = 25 * Math.cos(t) / (1 + Math.pow(Math.sin(t), 2));
            const y = 25 * Math.sin(t) * Math.cos(t) / (1 + Math.pow(Math.sin(t), 2));
            tar[i*3] = x; tar[i*3+1] = y; tar[i*3+2] = Math.sin(t*5)*3;
            col[i*3]=0.2; col[i*3+1]=0.6; col[i*3+2]=1;
        }
    }

    function setRose(growth) {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const t = i / PARTICLE_COUNT;
            const angle = 18 * Math.PI * t; 
            const radius = (25 * growth) * Math.sqrt(t); 
            tar[i*3] = Math.cos(angle) * radius;
            tar[i*3+1] = (Math.pow(t, 2) * 18) * growth - 10; 
            tar[i*3+2] = Math.sin(angle) * radius;
            col[i*3] = 0.5 + (growth * 0.5); col[i*3+1] = t * 0.1; col[i*3+2] = t * 0.2;
        }
    }

    function setYggdrasil() {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const seed = Math.random();
            if (seed < 0.2) { // Trunk
                tar[i*3]=(Math.random()-0.5)*2; tar[i*3+1]=(Math.random()-0.5)*40; tar[i*3+2]=(Math.random()-0.5)*2;
                col[i*3]=0.1; col[i*3+1]=0.5; col[i*3+2]=0.2;
            } else { // Branches/Roots
                const ang = Math.random()*Math.PI*2; const h = (Math.random()-0.5)*50;
                tar[i*3]=Math.cos(ang)*Math.abs(h)*0.7; tar[i*3+1]=h; tar[i*3+2]=Math.sin(ang)*Math.abs(h)*0.7;
                col[i*3]=0.2; col[i*3+1]=0.9; col[i*3+2]=0.4;
            }
        }
    }

    function setSphere() {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            tar[i*3] = 22 * Math.cos(theta) * Math.sin(phi);
            tar[i*3+1] = 22 * Math.sin(theta) * Math.sin(phi);
            tar[i*3+2] = 22 * Math.cos(phi);
            col[i*3]=0.8; col[i*3+1]=0.1; col[i*3+2]=1.0;
        }
    }

    function setScatter() {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            tar[i*3]=(Math.random()-0.5)*200; tar[i*3+1]=(Math.random()-0.5)*150; tar[i*3+2]=(Math.random()-0.5)*100;
            col[i*3]=0.3; col[i*3+1]=0.3; col[i*3+2]=0.6;
        }
    }

    setScatter();

    // --- 3. Hand Tracking (Refined) ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('sketch_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

    hands.onResults((results) => {
        // Clear and match canvas size to video
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            status.innerText = "SYSTEM STATUS: HAND DETECTED";
            const landmarks = results.multiHandLandmarks[0];
            
            // DRAW SKELETON
            window.drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FFCC', lineWidth: 5});
            window.drawLandmarks(canvasCtx, landmarks, {color: '#FF0055', lineWidth: 2, radius: 4});

            // GESTURE LOGIC
            const up = [8, 12, 16, 20].filter(id => landmarks[id].y < landmarks[id-2].y).length;
            const fist = landmarks[8].y > landmarks[5].y && landmarks[12].y > landmarks[9].y;

            if (fist) { if(mode!='sphere'){ mode='sphere'; setSphere(); roseGrowth=0; } }
            else if (up === 4) { if(mode!='mobius'){ mode='mobius'; setMobius(); roseGrowth=0; } }
            else if (up === 3) { if(mode!='rose'){ mode='rose'; } }
            else if (up === 2) { if(mode!='tree'){ mode='tree'; setYggdrasil(); roseGrowth=0; } }
            else { if(mode!='scatter'){ mode='scatter'; setScatter(); roseGrowth=0; } }
        } else {
            status.innerText = "SYSTEM STATUS: SEARCHING...";
            if(mode!='scatter'){ mode='scatter'; setScatter(); roseGrowth=0; }
        }
        canvasCtx.restore();
    });

    // --- 4. Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        const pArr = geometry.attributes.position.array;
        const cArr = geometry.attributes.color.array;
        globalTime += 0.02;

        if (mode === 'rose' && roseGrowth < 1) {
            roseGrowth += 0.01;
            setRose(roseGrowth);
        }

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            // Wind Effect
            const wind = Math.sin(globalTime + tar[i3+1] * 0.1) * 0.8;
            pArr[i3] += (tar[i3] + wind - pArr[i3]) * 0.12;
            pArr[i3+1] += (tar[i3+1] - pArr[i3+1]) * 0.12;
            pArr[i3+2] += (tar[i3+2] - pArr[i3+2]) * 0.12;
            cArr[i3] += (col[i3] - cArr[i3]) * 0.08;
            cArr[i3+1] += (col[i3+1] - cArr[i3+1]) * 0.08;
            cArr[i3+2] += (col[i3+2] - cArr[i3+2]) * 0.08;
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        points.rotation.y += 0.003;
        renderer.render(scene, camera);
    }

    document.getElementById('startBtn').onclick = () => {
        const cameraObj = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraObj.start().then(() => {
            document.getElementById('btn-container').style.display='none';
            status.innerText = "SYSTEM STATUS: CAMERA ACTIVE";
        });
    };

    animate();
</script>
</body>
</html>
