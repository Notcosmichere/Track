<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fluid Wave Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Consolas', monospace; }
        #ui-layer { position: absolute; top: 20px; left: 20px; color: #00ffcc; z-index: 100; pointer-events: none; }
        
        #debug-box { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 280px; height: 210px; 
            border: 2px solid #00ffcc; border-radius: 8px; 
            background: #000; z-index: 200;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #sketch_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); z-index: 201; }
        
        #btn-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 300; }
        button { padding: 15px 40px; font-size: 1.2rem; cursor: pointer; background: #00ffcc; border: none; font-weight: bold; border-radius: 4px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>HYDRO_WAVE_V3.0</h1>
    <div id="status">STATUS: INITIALIZING...</div>
</div>

<div id="btn-container"><button id="startBtn">START SIMULATION</button></div>

<div id="debug-box">
    <video id="input_video" playsinline></video>
    <canvas id="sketch_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const PARTICLE_COUNT = 12000; // Increased for "Wave" density
    const BOX_SIZE = 22; 
    const GRAVITY = -0.1;
    const BOUNCE = -0.4; // Softer bounce for liquid feel

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 40;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Cube
    const boxMesh = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(BOX_SIZE, BOX_SIZE, BOX_SIZE)),
        new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.3 })
    );
    scene.add(boxMesh);

    // Particles
    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const vel = new Float32Array(PARTICLE_COUNT * 3);
    const col = new Float32Array(PARTICLE_COUNT * 3);

    for(let i=0; i<PARTICLE_COUNT; i++) {
        pos[i*3] = (Math.random()-0.5) * BOX_SIZE;
        pos[i*3+1] = (Math.random()*BOX_SIZE) - (BOX_SIZE/2);
        pos[i*3+2] = (Math.random()-0.5) * BOX_SIZE;
        // Cyan to Blue Gradient
        col[i*3]=0; col[i*3+1]=0.8; col[i*3+2]=1.0; 
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const material = new THREE.PointsMaterial({ size: 0.25, vertexColors: true, blending: THREE.AdditiveBlending });
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // Tracking Setup
    const video = document.getElementById('input_video');
    const canvas = document.getElementById('sketch_canvas');
    const ctx = canvas.getContext('2d');
    let handPos = new THREE.Vector3(1000, 1000, 1000);

    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

    hands.onResults((res) => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const lm = res.multiHandLandmarks[0];
            // Fix: Explicitly draw the skeleton
            drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00FFCC', lineWidth: 3});
            drawLandmarks(ctx, lm, {color: '#FFFFFF', radius: 2});

            // Map index finger (tip is index 8)
            const tip = lm[8];
            handPos.set((tip.x - 0.5) * -BOX_SIZE * 2, (tip.y - 0.5) * -BOX_SIZE * 2, 0);
            document.getElementById('status').innerText = "STATUS: TRACKING ACTIVE";
        } else {
            handPos.set(1000, 1000, 1000);
            document.getElementById('status').innerText = "STATUS: SEARCHING FOR HAND...";
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        const pArr = geometry.attributes.position.array;
        const h = BOX_SIZE / 2;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3, iy = i*3+1, iz = i*3+2;

            vel[iy] += GRAVITY;

            // WAVE PHYSICS: Check distance to hand
            const dx = pArr[ix] - handPos.x;
            const dy = pArr[iy] - handPos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if(dist < 7) {
                const force = (7 - dist) / 7;
                vel[ix] += (dx/dist) * force * 0.8;
                vel[iy] += (dy/dist) * force * 0.8;
            }

            // Movement
            pArr[ix] += vel[ix]; pArr[iy] += vel[iy]; pArr[iz] += vel[iz];

            // Boundaries
            if (Math.abs(pArr[ix]) > h) { pArr[ix] = Math.sign(pArr[ix])*h; vel[ix] *= BOUNCE; }
            if (pArr[iy] < -h) { pArr[iy] = -h; vel[iy] *= BOUNCE; vel[ix] *= 0.95; vel[iz] *= 0.95; }
            if (pArr[iy] > h) { pArr[iy] = h; vel[iy] *= BOUNCE; }
            if (Math.abs(pArr[iz]) > h) { pArr[iz] = Math.sign(pArr[iz])*h; vel[iz] *= BOUNCE; }
        }

        geometry.attributes.position.needsUpdate = true;
        scene.rotation.y += 0.003;
        renderer.render(scene, camera);
    }

    document.getElementById('startBtn').onclick = () => {
        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });
        cam.start().then(() => {
            document.getElementById('btn-container').style.display='none';
            animate();
        });
    };
</script>
</body>
</html>
